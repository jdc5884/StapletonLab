allP = c(allP, calib_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
View(calib_data)
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_data = calib_df
## Let's do without this ?###
write.csv(calib_df, file="2018_11_Calibrated_Data_Frame.csv")
# Create new transposed data set
calib_data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
View(calib_data)
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
class(calib_df)
View(calib_df)
calib_data = calib_df
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
View(calib_data)
head(startq)
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_data = calib_df
## Let's do without this ?###
write.csv(calib_df, file="2018_11_Calibrated_Data_Frame.csv")
# Create new transposed data set
calib_data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
View(calib_data)
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_data = calib_df
test1 = c()
allP = c()
startq = c()
calib_data$starting_quantity
i = 1
test1 = c()
allP = c()
startq = c()
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
startq
allP
test1
head(calib_data$starting_quantity)
class(calib_data$starting_quantity)
# Create new transposed data set
calib_data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
class(calib_data$starting_quantity)
calib_df$starting_quantity = as.numeric(calib_df$starting_quantity)
calib_data = calib_df
test1 = c()
allP = c()
startq = c()
calib_data$starting_quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(calib_df$starting_quantity)
calib_data = calib_df
calib_data$starting_quantity
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_data$starting_quantity
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_df$starting_quantity
calib_data = calib_df
test1 = c()
allP = c()
startq = c()
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
View(calib_data)
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
View(calib_data)
#data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
# Create empty vectors for for-loop input
data = as.data.frame(calib_data)
adj_val = c()
allP = c()
startq = c()
ratio = as.numeric(data$allP)/as.numeric(data$test1)
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
ratio = as.numeric(as.character(data$allP))/as.numeric(as.character(data$test1))
data = as.data.frame(calib_data)
adj_val = c()
allP = c()
startq = c()
ratio = as.numeric(as.character(data$allP))/as.numeric(as.character(data$test1))
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
adjusted_test1 <- test1 + adj_val
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better --> VERIFY THIS WITH DR. WANG
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
par(mfrow = c(2,2))
plot(adj_model)
scatter.smooth(ratio, adj_val)
abline(ratio, adj_val)
dev.off()
### QPCR PLATE FRAMING & ADJUSTMENT MODEL ###
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
deriv.1<-read.csv(file = "2018_11_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_11_2_plate_qPCR_output.csv", header=FALSE)
deriv=cbind(deriv.1, deriv.2)
deriv = deriv[-1,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_data = calib_df
test1 = c()
allP = c()
startq = c()
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
View(calib_data)
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
View(calib_data)
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
#data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
# Create empty vectors for for-loop input
data = as.data.frame(calib_data)
adj_val = c()
allP = c()
startq = c()
ratio = as.numeric(as.character(data$allP))/as.numeric(as.character(data$test1))
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
adjusted_test1 <- test1 + adj_val
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better --> VERIFY THIS WITH DR. WANG
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
head(adjusted_test1)
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better --> VERIFY THIS WITH DR. WANG
adj_model <- lm(adjusted_test1~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
deriv.1<-read.csv(file = "2018_11_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_11_2_plate_qPCR_output.csv", header=FALSE)
deriv=cbind(deriv.1, deriv.2)
## INITIAL DATA FRAMING ###
# Remove extra labels row,
deriv = deriv[-1,]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Remove extra labels row
deriv=deriv[-1,]
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
write.csv(deriv, file="2018_11_qPCR_output_withHeaders.csv")
# Create new transposed data set
deriv2=read.csv(file="2018_11_qPCR_output_withHeaders.csv", header=TRUE)
# Remove unneeded labeling column
deriv2=deriv2[,-1]
# Indicate if sample is NTC (negative control)
deriv2['sampleID_NTC'] = grepl('NTC', deriv2$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv2$sampleID_NTC)
deriv2 = deriv2[-ntc,]
deriv2 = deriv2[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv2['sampleID_Minus'] = grepl('minus', deriv2$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv2$sampleID_Minus)
deriv2 = deriv2[-minus,]
deriv2 = deriv2[,-c(5)]
# Write CSV file
# Write CSV file
write.csv(deriv2, file="2018_11_qPCR_output_New.csv")
# Re-read in CSV values --> this allows for-loop to work properly
deriv2=read.csv(file="2018_11_qPCR_output_New.csv", header=TRUE)
# Remove labels column
deriv2=deriv2[,-1]
### CALIBRATED DATA FRAME ###
# Create/Write data frame for Calibrated values
calib_df = deriv2 %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
write.csv(calib_df, file="2018_11_Calibrated_Data_Frame.csv")
# Create new transposed data set
calib_data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
write.csv(calib_data, file="2018_11_Calibrated_Data_Frame.csv")
### ADJUSTMENT MODEL - CALIBRATED DATA ###
data=read.csv(file="2018_11_Calibrated_Data_Frame.csv", header=TRUE)
# Create empty vectors for for-loop input
adj_val = c()
allP = c()
startq = c()
ratio = data$allP/data$test1
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
adjusted_test1 <- test1 + adj_val
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better --> VERIFY THIS WITH DR. WANG
adj_model <- lm(adj_val~ratio) #Adjusted/avg slopes model --> to get JC VQTL vals
summary(adj_model)
par(mfrow = c(2,2))
plot(adj_model)
### EXPERIMENTAL DATA FRAME ###
# Create/Write data frame for Calibrated values
exp_df = deriv2 %>% filter(str_detect(sampleID, "g")==FALSE)
compare_data = cbind(adj_val, allP, startq, ratio)
write.csv(file= "compare_dataDrew.csv", compare.data)
write.csv(file= "compare_dataDrew.csv", compare_data)
View(compare_data)
head(startq)
compare_data = cbind(adj_val,ratio)
write.csv(file= "compare_dataDrew.csv", compare_data)
write.csv(file= "compare_dataDrew.csv", compare_data)
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_11_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_11_2_plate_qPCR_output.csv", header=FALSE)
deriv=cbind(deriv.1, deriv.2)
deriv = deriv[-1,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_data = calib_df
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
# Create empty vectors for for-loop input
data = as.data.frame(calib_data)
adj_val = c()
allP = c()
startq = c()
ratio = as.numeric(as.character(data$allP))/as.numeric(as.character(data$test1))
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
adjusted_test1 <- test1 + adj_val ### where does this apply???
compare_data = cbind(adj_val, ratio)
write.csv(file = "compare_dataJulia.csv", compare_data)
### do without this ####
write.csv(calib_data, file="2018_11_Calibrated_Data_Frame_Julia.csv")
calib_df$cpD1 = as.numeric(as.character(calib_df$cpD1))
calib_data = calib_df
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_df$cpD1 = as.numeric(as.character(calib_df$cpD1))
calib_data = calib_df
test1 = c()
allP = c()
startq = c()
for(i in 1:length(calib_data$starting_quantity)){
sq <- calib_data$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_data$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
### do without this ####
write.csv(calib_data, file="2018_11_Calibrated_Data_Frame_Julia.csv")
### COMPLETED CALIBRATED DATA FRAME ###
### do without this ####
write.csv(calib_data, file="2018_11_Calibrated_Data_Frame_Julia.csv")
data = as.data.frame(calib_data)
adj_val = c()
allP = c()
startq = c()
ratio = as.numeric(as.character(data$allP))/as.numeric(as.character(data$test1))
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
adjusted_test1 <- test1 + adj_val ### where does this apply???
# Creating the adjustment model lm(y-axis~x-axis)
# Changed adj_val^2 to adj_val to try to make the model better --> VERIFY THIS WITH DR. WANG
adj_model <- lm(adj_val~ratio) #Adjusted/
summary(adj_model)
class(data$startq)
