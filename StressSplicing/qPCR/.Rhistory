x = c(2,6,16,24,28,29,69,40,33,100,99,69,45,4,8,69,69,15,12,1,21,5,4,8,115,04,5,2)
hist(x)
student =c("Jessica", "Julia", "Drew", "Michael")
grades =c(75,80,85,90,95,100)
sNum =c("1", "2", "3", "4")
SGNumb =c("1", "4", "2", "3", "4")
studentInfo = cbind(student, sNum)
colnames(studentInfo) =c("StudentName", "StudentNumber")
studentGrade = cbind(SGNumb, grades)
colnames(studentGrade) =c("StudentNumber", "Grade")
grades =c(75,80,85,90,95)
studentGrade = cbind(SGNumb, grades)
colnames(studentGrade) =c("StudentNumber", "Grade")
merge(studentInfo, studentGrade, by = "StudentNumber")
setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing/qPCR")
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
# Mac Directory
#setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_11")
#setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_(MONTH)")
# PC Directory
#setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing/qPCR")
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_11_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_11_2_plate_qPCR_output.csv", header=FALSE)
deriv=cbind(deriv.1, deriv.2)
# In the case of having one CSV containing calculated derivatives, use this code:
#deriv=read.csv(file = "(YEAR_MONTH_PLATE_qPCR_output.csv", header=FALSE)
##########################################################
################### Initial Data Framing #################
##########################################################
# Remove extra labels row and column
deriv = deriv[-1,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
############################
## Removing NTC and Minus ##
############################
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
### COMPLETED INITIAL DATA FRAMING ###
##########################################################
################# Calibrated Data Framing ################
##########################################################
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_df$cpD1 = as.numeric(as.character(calib_df$cpD1))
#calib_data = calib_df    Do we need this?
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_df$starting_quantity)){
sq <- calib_df$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_df$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_df$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_df$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
### COMPLETED CALIBRATED DATA FRAME ###
require(MASS)
startq = as.factor(calib_data[,1])
test1 = calib_data[,2]
allP = calib_data[,3]
OLR = polr(startq~test1+allP, Hess = TRUE)
summary(OLR)
log = glm(start~test1+allP, family = binomial())
log = glm(startq~test1+allP, family = binomial())
summary(log)
logit = glm(startq~test1+allP, family = binomial())
logit.prob = predict(logit, calib_data, type = "response")
logit.prob = predict(logit, as.data.frame(calib_data), type = "response")
class(logit.prob)
logit.prob
length(logit.prob)
class(logit)
logit
head(logti)
head(logit)
dim(calib_data)
View(calib_data)
?glm()
summary(OLR)
library(ISLR)
summary(OLR)
head(calib_data)
names(calib_data)
calib_data$startq
data$startq
head(data)
(ctable <- coef(summary(OLR)))
startq
head(test1)
head(allp)
head(allP)
calib_data = cbind(startq, test1, allP)
names(calib_data)
#ordinal logistic
OLR = polr(startq~allP+test1, Hess = TRUE)
summary(OLR)
45.25*17.5+16*12
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_df$starting_quantity)){
sq <- calib_df$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_df$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_df$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_df$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = cbind(startq, test1, allP)
names(calib_data)
ex = cbind(a,b,c)
a = c(1,2,3,4)
b = c(2,3,4,5)
c = c(3,4,5,6)
ex = cbind(a,b,c)
ex
names(ex)
source('~/.active-rstudio-document', echo=TRUE)
ex
names(ex)
ex = as.data.frame(cbind(a,b,c))
colnames(ex) = c("a", "b", "c")
names(ex)
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = as.data.frame(cbind(startq, test1, allP))
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
#ordinal logistic
OLR = polr(startq~allP+test1,data = calib_data, Hess = TRUE)
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = as.data.frame(cbind(as.factor(startq), test1, allP))
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=format(calib_data[,1], scientific=FALSE)
#ordinal logistic
OLR = polr(startq~allP+test1,data = calib_data, Hess = TRUE)
# Format starting quantity values as decimals, not scientific notation
calib_data[,1]=as.factor(format(calib_data[,1], scientific=FALSE))
#ordinal logistic
OLR = polr(startq~allP+test1,data = calib_data, Hess = TRUE)
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = as.data.frame(cbind(startq, test1, allP))
# Format starting quantity values as decimals, not scientific notation
calib_data$startq=as.factor(format(calib_data$startq, scientific=FALSE))
#ordinal logistic
OLR = polr(startq~allP+test1,data = calib_data, Hess = TRUE)
View(calib_data)
View(calib_df)
27*2
View(calib_data)
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_df$starting_quantity)){
sq <- calib_df$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_df$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_df$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_df$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = as.data.frame(cbind(startq, test1, allP))
# Format starting quantity values as decimals, not scientific notation
#calib_data$startq=as.factor(format(calib_data$startq, scientific=FALSE))
calib_data$startq=as.factor(calib_data$startq)
View(calib_data)
#ordinal logistic
OLR = polr(startq~allP+test1,data = calib_data, Hess = TRUE)
?polr()
#ordinal logistic
OLR = polr(startq~test1+allP,data = calib_data, Hess = TRUE)
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
# Mac Directory
#setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_11")
#setwd("~/Stapleton_Lab/Stapleton_Lab/Stress_Splicing/2018_(MONTH)")
# PC Directory
#setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing/qPCR")
### READ IN DERIVATIVE DATA###
# In the case of having two separate CSV files of calculated derivatives,
# use this code to combine, prior to the following transpositions:
deriv.1<-read.csv(file = "2018_11_1_plate_qPCR_output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_11_2_plate_qPCR_output.csv", header=FALSE)
deriv=cbind(deriv.1, deriv.2)
# In the case of having one CSV containing calculated derivatives, use this code:
#deriv=read.csv(file = "(YEAR_MONTH_PLATE_qPCR_output.csv", header=FALSE)
##########################################################
################### Initial Data Framing #################
##########################################################
# Remove extra labels row and column
deriv = deriv[-1,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
############################
## Removing NTC and Minus ##
############################
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
### COMPLETED INITIAL DATA FRAMING ###
##########################################################
################# Calibrated Data Framing ################
##########################################################
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_df$cpD1 = as.numeric(as.character(calib_df$cpD1))
#calib_data = calib_df    Do we need this?
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_df$starting_quantity)){
sq <- calib_df$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_df$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_df$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_df$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = as.data.frame(cbind(startq, test1, allP))
# Format starting quantity values as decimals, not scientific notation
#calib_data$startq=as.factor(format(calib_data$startq, scientific=FALSE))
calib_data$startq=as.factor(calib_data$startq)
### COMPLETED CALIBRATED DATA FRAME ###
##########################################################
##### Ordinal Logicistic Regression Calibrated Data ######
##########################################################
require(MASS)
#ordinal logistic
OLR = polr(startq~test1+allP,data = calib_data, Hess = TRUE)
head(test1)
startq = as.factor(calib_data[,1])
OLR = polr(startq~test1+allP, Hess = TRUE)
