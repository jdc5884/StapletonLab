divide(a, b)
for (i in len(a)){
i/b
}
for (i in length(a)){
i/b
}
a
x = for (i in length(a)){
i/b
}
x
b
for (i in a){
i/b
}
a
b
m
div = rbind(div,i/b)
div = c()
for (i in a){
div = rbind(div,i/b)
}
div
x = c("a", "a", "b", "b")
m = cbind(x,a,b)
names(m)
m
div = c()
for (sq in x){
for (i in a){
div = rbind(div,i/b)
}
}
div
258*1.12
/3
288.96/
3
359.48*1.1
359.48*1.1/3
359.48/3
(359.48*1.1)/3
395.43/3
(395.43/3)-96.32
### developing code for combination ratios for qPCR ###
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
group = split(m, name)
for (k in group){
#print(divide(k$a, k$b))
print(k)
}
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
group
group$y
what = group$y
divide(what$a, what$b)
class(what$a)
divide(what$a[1], what$b[1])
what$a[1]
class(what$a[1])
what$a[1]/2
what$a[1]/what$b[1]
divide(what$a, what$b)
divide(group$x$a, group$x$b)
group$x$a[1]/group$x$b[1]
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this function divides every i
# split the matrix by each group
group = split(m, name)
#for each group in k, divide column a by column b
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
# split the matrix by each group
group = split(m, name)
print(group)
#for each group in k, divide column a by column b
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
group = group[-(name)]
group = group[-(group$name)]
group = group[-(group$name),]
print(group)
#print(divide(k$a, k$b))
print(k)
#for each group in k, divide column a by column b
for (k in group){
k = k[-(name),]
#print(divide(k$a, k$b))
print(k)
}
what
what[-name]
what[-1,]
#for each group in k, divide column a by column b
for (k in group){
k = k[.-(name)]
#print(divide(k$a, k$b))
print(k)
}
what[,-name]
what[,-1]
k = k[.-1]
k = k[,-1]
#for each group in k, divide column a by column b
for (k in group){
k = k[,-1]
#print(divide(k$a, k$b))
print(k)
}
#for each group in k, divide column a by column b
for (k in group){
k = k[,-1]
print(divide(k$a, k$b))
#print(k)
}
group$1
#for each group in k, divide column a by column b
for (k in group){
print(divide(group$k$a, group$k$b))
#print(k)
}
group$y$a
group$x$a
class(group$x$a)
class(group$y$a)
k = 1
print(divide(k$a, k$b))
#for each group in k, divide column a by column b
names = c('x', 'y', 'z')
for (k in names){
print(divide(group$k$a, group$k$b))
#print(k)
}
#for each group in k, divide column a by column b
names = c('x', 'y', 'z')
for (k in names){
print(divide(group$k$a, group$k$b))
#print(k)
}
#print(divide(group$k$a, group$k$b))
print(k)
for (k in names){
#print(divide(group$k$a, group$k$b))
print(k)
}
print(divide(group$k$a, group$k$b))
for (k in names){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
group$names[1]
names[1]
group$(names[1])
#for each group in k, divide column a by column b
names = c(x, y, z)
#for each group in k, divide column a by column b
names = c('x', 'y', 'z')
for (k in names){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
for (k in names){
#print(divide(group$k$a, group$k$b))
print(k)
}
group$'x'
group$"x"
for (k in names){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
print(k)
group$k
group$print(k)
for (k in group){
print(divide(group$k$a, group$k$b))
print(group$k)
}
for (k in group){
#print(divide(group$k$a, group$k$b))
print(group$k)
}
for (k in group){
#print(divide(group$k$a, group$k$b))
print(k)
}
k
k$a
k$a/k$b
divide(k$a, k$b)
k$a
k$a[1]
k$a[1]/k$b
k$a[2]/k$b
for (k in group){
print(divide(k$a, k$b))
print(k)
}
divide(k$a, k$b)
k$a
class(k$a)
for (k in group){
print(divide(c(k$a), c(k$b)))
#print(k)
}
divide(m$a, m$b)
class(m$a)
for (k in group){
A = k$a
B = k$b
print(divide(A, B))
#print(k)
}
for (k in group){
A = c(k$a)
B = c(k$b)
print(divide(A, B))
#print(k)
}
library(tidyverse)
m %>%
group_by(name) %>%
summarise(a.mean = mean(a))
m %>%
group_by(name) %>%
divide(a/b)
m %>%
group_by(name) %>%
divide(a,b)
gapply(m, name = "x", divide(k$a,k$b))
library(apply)
install.packages("apply")
library(apply)
install.packages("gapply")
library(gapply)
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this function divides every item in column 1 by every item in column 2
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
# split the matrix by each group
group = split(m, name)
one = group$x
two = group$y
three = group$z
divide(one$a, one$b)
divide(two$a, two$b)
group = split(m, name)
print(group)
one = group$x
two = group$y
three = group$z
divide(two$a, two$b)
two
two = as.data.frame(group$y)
two
divide(two$a, two$b)
A = group$y$a
B = group$y$b
divide(A, B)
### developing code for combination ratios for qPCR ###
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this fu
m
# this function divides every item in column 1 by every item in column 2
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
divide(m$a, m$b)
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
divide(m$a, m$b)
# split the matrix by each group
group = split(m, name)
print(group)
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
for (k in group){
print(divide(k$b, k$a))
#print(k)
}
print(divide(k$a, k$b))
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
library(vqtl)
?mean.qtl.dom
??mean.qtl.dom
### developing code for combination ratios for qPCR ###
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this function divides every item in column 1 by every item in column 2
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
divide(a,b)
# split the matrix by each group
group = split(m, name)
print(group)
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing/qPCR")
# In the case of having one CSV containing calculated derivatives, use this code:
#deriv=read.csv(file = "(YEAR_MONTH_PLATE_qPCR_output.csv", header=FALSE)
deriv=read.csv(file = "2018_06_01_plate_qPCR_output_2019_04_04.csv", header=FALSE)
# Remove extra labels row and column
deriv = deriv[-1,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
##########################
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
#########################################################
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_df$cpD1 = as.numeric(as.character(calib_df$cpD1))
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_df$starting_quantity)){
sq <- calib_df$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_df$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_df$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_df$cpD1[i])
}
}
# Bind test1
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = as.data.frame(cbind(startq, test1, allP))
# Format starting quantity values as decimals, not scientific notation
#calib_data$startq=as.factor(format(calib_data$startq, scientific=FALSE))
calib_data$startq=as.factor(calib_data$startq)
##########################################################
exp_df = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
# Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
#exp_df$sampleID = as.numeric(as.character(exp_df$sampleID))
exp_df$cpD1 = as.numeric(as.character(exp_df$cpD1))
exp_data = exp_df
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
### Finding invalid observations ###
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
countsne2$Var1 = as.numeric(as.character(countsne2$Var1)) #---> CHECK IF THIS IS NECESSARY
# Remove invalid observations from data set
exp_data = exp_data[!exp_data$sampleID %in% countsne2$Var1,]
# Create empty vectors for for-loop to input cpD1 values
test1.exp = c()
allP.exp = c()
sampleID.exp = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(exp_data$sampleID)){
id.exp = toString(exp_data$sampleID[i])
if(i %% 2 == 1){
sampleID.exp = c(sampleID.exp, id.exp)
}
val = toString(exp_data$reaction_type[i])
if(strcmp(val, "test1")){
test1.exp = c(test1.exp, exp_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP.exp = c(allP.exp, exp_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by sample ID
exp_data = data.frame(sampleID.exp, test1.exp, allP.exp, stringsAsFactors = FALSE)
exp_ratio = as.numeric(exp_data$allP.exp)/as.numeric(exp_data$test1.exp)
# Write CSV file
# Bind test1 and allProd cpD1 values by sample ID
exp_data = data.frame(sampleID.exp, test1.exp, allP.exp, stringsAsFactors = FALSE)
### developing code for combination ratios for qPCR ###
name = c('x','x','y','y','z','z')
a = c(1,2,3,4,5,6)
b = c(7,8,9,10,11,12)
m = data.frame(cbind(name,a,b), stringsAsFactors = FALSE)
# this function divides every item in column 1 by every item in column 2
divide <- function(col1, col2){
r = c()
for (i in col1){
r = cbind(r,col1[i]/col2)
}
return(r)
}
# change the components of the matrix to numeric
m$a = as.numeric(m$a)
m$b = as.numeric(m$b)
divide(a,b)
# split the matrix by each group
group = split(m, name)
print(group)
typeof(a)
calss(a)
class(a)
# split the matrix by each group
group = split(m, m$name)
print(group)
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
# split the matrix by each group
group = split.data.frame(m, m$name)
print(group)
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
group$y
divide(group$y$a, group$y$b)
divide(sub$a, sub$b)
sub
sub = group$y
sub
divide(sub$a, sub$b)
for (k in group){
print(divide(k$a, k$b))
#print(k)
}
