r=(12,12,12,)
c
r=c(12,12,12,)
r=12,13,13
r=c(12,13,13)
e=c(13,14,14)
c=c(13,13,4)
rec
r*e*c
r*
e*
c*.
fesdf
mySum(input_1 = 1, 3)
input_1 <- 20
mySum <- function(input_1, input_2 = 10) {
output <- input_1 + input_2
return(output)
}
}
mySum(input_1 = 1, 3)
mySum(3)
mySum(input_2 = 3)
center <- function(data, desired) {
new_data <- (data - mean(data)) + desired
return(new_data)
}
z<-c(1,2,3,4,5,6,7,8,9,10)
center(z)
center(z,4)
mean(center(z,4))
z<-c(0,0,0,0)
center(z,3)
dat <- read.csv(file = "data/inflammation-01.csv", header = FALSE)
centered <- center(dat[, 4], 0)
head(centered)
install.packages("qtl2", repos="http://rqtl.org/qtl2cran")
z<-c(0,0,0)
z<-c(0,0,0,0)
print("Hello")
print("Bom dia")
source('~/stapleton_lab/Test2.R')
install.packages("qtl")
vqtl
install.packages("purrr")
install.packages("readr")
install.packages("dplyr")
print("Bom Dia meus amigos!")
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
library(qtl)
library(qtl)
library(qtl)
summary(hyper)
data("hyper")
summary(hyper)
nind(hyper)
nphe(hyper)
nchr(hyper)
totmar(hyper)
nmar(hyper)
plot(hyper)
data
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
install.packages("readr")
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
dat <- read.cross(file = "./Manching_Practice_Data.csv")
summary(dat)
#vQTL with simulated data
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
# setwd("/Users/mbyrd/StapletonLab/Stapleton_Lab/vQTL_Practice")
# Michael Stampede Path
# setwd ("/work/04908/mcb4548/stampede2/GitHub/Stapleton_Lab/vQTL_Practice")
dat <- read.cross(file = "./Manching_Practice_Data.csv")
# Not sure what this does. Was told by Thomas its needed.
dat <- drop.nullmarkers(dat)
#scan with variance
dat <- calc.genoprob(dat)
###
#vQTL with simulated data
library(qtl)
library(vqtl)
library(purrr)
library(readr)
library(dplyr)
# setwd("/Users/mbyrd/StapletonLab/Stapleton_Lab/vQTL_Practice")
# Michael Stampede Path
# setwd ("/work/04908/mcb4548/stampede2/GitHub/Stapleton_Lab/vQTL_Practice")
dat <- read.cross(file = "./Manching_Practice_Data.csv")
# Not sure what this does. Was told by Thomas its needed.
dat <- drop.nullmarkers(dat)
#scan with variance
dat <- calc.genoprob(dat)
###
### Combining Genomes and Mo###
library(stringr)
#setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing")
setwd("/Users/andrewnorris/stapleton_lab/JCastillo/StapletonLab/StressSplicing")
dat = read.csv(file = "Plant_Height.csv", header = TRUE)
#Take out unneeded IBMB###, NA, B73 loci
dat = dat[-(907:938),-(4:5)]
#Create Categorical Variables for PH207*Mo### and Mo### by gene breed
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Outbred")
dat = cbind(dat, BreedType)
#Add in SNP info from CSV, beginning with column six
snp = read.csv(file = "IBM94markerset08seq.csv")
snp = snp[,-(1:5)]
#Create zero matrix to which data will input
relevant = data.frame(matrix(rep(0,length(dat$Genotype)*dim(snp)[1]), ncol = dim(snp)[1]))
#From
dat2 = sapply(str_sub(dat$Genotype,-3,-1), function(x){
column = which(str_sub(colnames(snp),-3,-1) == x)
vect = data.frame(as.character(snp[,column]))
return(vect)
})
View(dat2)
#From "Genotype" values,
dat2 = sapply(str_sub(dat$Genotype,-3,-1), function(x){
column = which(str_sub(colnames(snp),-3,-1) == x)
vect = data.frame(as.character(snp[,column]))
return(vect)
})
dat2 = as.data.frame(matrix(unlist(dat2), nrow = dim(dat)[1], byrow = TRUE))
View(dat2)
#Add matched Mo### values to data frame
dat2 = as.data.frame(matrix(unlist(dat2), nrow = dim(dat)[1], byrow = TRUE))
colnames(dat2) = colnames()
library(beepr)
beep()
dim(dat3);dim(snp)
#####Adding back in the Trait info#####
dat3 = cbind(dat2$Height,dat2[,1:3],dat3)
### Combining Genomes and Mo###
library(stringr)
setwd("/Users/andrewnorris/stapleton_lab/Stress_Splicing")
#setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing")
dat = read.csv(file = "Plant_Height.csv", header = TRUE)
#Take out unneeded IBMB###, NA, B73 loci
dat = dat[-(907:938),-(4:5)]
#Create Categorical Variables for PH207*Mo### and Mo### by gene breed
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Outbred")
dat = cbind(dat, BreedType)
#Add in SNP info from Marker data CSV, beginning with column six
snp = read.csv(file = "IBM94markerset08seq.csv")
snp = snp[,-(1:5)]
#Create zero matrix to which data will input
relevant = data.frame(matrix(rep(0,length(dat$Genotype)*dim(snp)[1]), ncol = dim(snp)[1]))
#From "Genotype" values, match Plant Height data and Marker data by detecting last three digits of Mo###'s
dat2 = sapply(str_sub(dat$Genotype,-3,-1), function(x){
column = which(str_sub(colnames(snp),-3,-1) == x)
vect = data.frame(as.character(snp[,column]))
return(vect)
})
#Add matched Mo### values to data frame
dat2 = as.data.frame(matrix(unlist(dat2), nrow = dim(dat)[1], byrow = TRUE))
View(dat2)
#####Adding marker location and chromosome#####
aux = matrix(snp$incre_new, nrow= 1)
#####Adding back in the Trait info#####
dat3 = cbind(dat2$Height,dat2[,1:3],dat3)
relevant = data.frame(matrix(rep(0,length(dat$sampleID)*dim(exp_data)[1]), ncol = dim(exp_data)[1]))
## If zero matrix is the way to go... #Create zero matrix to which data will input
relevant = data.frame(matrix(rep(0,length(data$sampleID)*dim(exp_data)[1]), ncol = dim(exp_data)[1]))
## If zero matrix is the way to go... #Create zero matrix to which data will input
relevant = data.frame(matrix(rep(0,length(data$sampleID)*dim(exp_data)[1]), ncol = dim(exp_data)[1]))
# Mac Directory
setwd("/Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
# Mac Directory
setwd("/Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
# Mac Directory
setwd("/Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
library(tidyr)
# Mac Directory
setwd("/Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
# Mac Directory
setwd("Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
# Read in Calibration Data
data <- read.csv(file = "2018_6_1_Calibrated_Data_Frame_with_Derivatives.csv")
# Mac Directory
setwd("/Users/andrewnorris/Stapleton_Lab/Stress_Splicing/2018_6")
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
library(MASS)
library(glm.predict)
setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing/qPCR")
# In the case of having one CSV containing calculated derivatives, use this code:
#deriv=read.csv(file = "(YEAR_MONTH_PLATE_qPCR_output.csv", header=FALSE)
deriv=read.csv(file = "2018_06_01_plate_qPCR_output_2019_04_04.csv", header=FALSE)
# Remove extra labels row and column
deriv = deriv[-1,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Remove blank column (4th)
#deriv = deriv[,-5]
# Rename columns
colnames(deriv)=c("reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Remove extra labels row
deriv=deriv[-1,]
### Removing NTC and gblock-Minus values ###
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(5,6)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
deriv = deriv[-minus,]
deriv = deriv[,-c(5)]
### COMPLETED INITIAL DATA FRAMING ###
##########################################################
################# Calibrated Data Framing ################
##########################################################
# Create/Write data frame for Calibrated values
calib_df = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_df = calib_df[order(calib_df$starting_quantity),]
calib_df$starting_quantity = as.numeric(as.character(calib_df$starting_quantity))
calib_df$cpD1 = as.numeric(as.character(calib_df$cpD1))
calib_data = calib_df
# Create empty vectors for for-loop to input cpD1 values
test1 = c()
allP = c()
startq = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(calib_df$starting_quantity)){
sq <- calib_df$starting_quantity[i]
if(i %% 6 == 1){
startq = c(startq,sq,sq,sq)
}
val <- toString(calib_df$reaction_type[i])
if(strcmp(val, "test1")){
test1 = c(test1, calib_df$cpD1[i])
}
if(strcmp(val, "all_products")){
allP = c(allP, calib_df$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by starting quantity
calib_data = as.data.frame(cbind(startq, test1, allP))
# Format starting quantity values as decimals, not scientific notation
calib_data$startq=as.factor(format(calib_data$startq, scientific=FALSE))
calib_data$startq=as.factor(calib_data$startq)
ratio = calib_data$allP/calib_data$test1
# Append ratios to data set
calib_data = cbind(calib_data, ratio)
### COMPLETED CALIBRATED DATA FRAME ###
##########################################################
################ Experimental Data Framing ###############
##########################################################
# Create/Write data frame for Experimental values
exp_df = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_df = exp_df[order(exp_df$starting_quantity),]
# Remove first and last rows (unnecessary labeling)
exp_df = exp_df[-1,]
exp_df = exp_df[-nrow(exp_df),]
#exp_df$sampleID = as.numeric(as.character(exp_df$sampleID))
exp_df$cpD1 = as.numeric(as.character(exp_df$cpD1))
exp_data = exp_df
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
### Finding invalid observations ###
# Find counts of each unique sampleID; for sample with a count not equal to 2, remove from data frame
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
countsne2$Var1 = as.numeric(as.character(countsne2$Var1)) #---> CHECK IF THIS IS NECESSARY
# Remove invalid observations from data set
exp_data = exp_data[!exp_data$sampleID %in% countsne2$Var1,]
### Report invalid observations ###
# Send CSV of removed sampleID's to Dr. S (invalid obs), with additional plots of raw cycle values for invalid obs
# Write CSV file to send Dr. S for investigation
### WORK ON --> add derivative values in to the CSV file
### WORK ON --> creating a separate CSV file with samples with unusual derivatives
#write.csv(file="2018_11_SamplesToInvestigate", countsne2)
#write.csv(file="YEAR_MONTH_SamplesToInvestigate", countsne2)
# Create empty vectors for for-loop to input cpD1 values
test1.exp = c()
allP.exp = c()
sampleID.exp = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(exp_data$sampleID)){
id.exp = toString(exp_data$sampleID[i])
if(i %% 2 == 1){
sampleID.exp = c(sampleID.exp, id.exp)
}
val = toString(exp_data$reaction_type[i])
if(strcmp(val, "test1")){
test1.exp = c(test1.exp, exp_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP.exp = c(allP.exp, exp_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by sample ID, convert to data frame
exp_data = as.data.frame(cbind(sampleID.exp, test1.exp, allP.exp))
#exp_data$sampleID.exp = as.numeric(as.character(exp_data$sampleID.exp))
exp_data$test1.exp = as.numeric(as.character(exp_data$test1.exp))
exp_data$allP.exp = as.numeric(as.character(exp_data$allP.exp))
# Calculate ratios for experimental data
ratio.exp = exp_data$allP.exp/exp_data$test1.exp
# Append ratios to data set
exp_data = cbind(exp_data, ratio.exp)
# Write Experimental Data CSV --> Used in "qPCR_Plotting" code for visuals
#write.csv(file="YEAR_MONTH_Experimental_DF", exp_data)
### COMPLETED EXPERIMENTAL DATA FRAME ###
###################################
### combination ratios for qPCR ###
###################################
library(glm.predict)
#Calculate z-score for calibrated data
calib.zscore = (newratios$combratio - mean(newratios$combratio))/sd(newratios$combratio)
#Predict calibrated data ratios using experimental data
y = calib.zscore*sd(ratio.exp)+mean(ratio.exp)
# Create empty vectors for for-loop input
data = as.data.frame(calib_data)
data$test1 = as.numeric(as.character(data$test1))
data$allP = as.numeric(as.character(data$allP))
adj_val = c()
allP = c()
startq = c()
ratio =data$allP/data$test1
# Itterating through each set of (3) observations performing U-Stats on each set of inputs
for (i in 1:(nrow(data)/3)){
t_x <- c(data$allP[3*i - 2], data$allP[3*i - 1], data$allP[3*i])
t_y <- c(data$test1[3*i - 2], data$test1[3*i - 1], data$test1[3*i])
adj <- mean(outer(t_x, t_y, "-"))
adj_val <- c(adj_val, adj, adj, adj)
}
adjusted_test1 <- test1 + adj_val
# Append adjusted test1 values and adjustment value to data set
calib_data=cbind(data,adjusted_test1,adj_val)
# Write Calibrated Data CSV --> Used in "qPCR_Plotting" code for visuals
#write.csv(file="YEAR_MONTH_Calibrated_DF", calib_data)
#Calculate z-score for calibrated data
calib.zscore = (calib_data$ - mean(newratios$combratio))/sd(newratios$combratio)
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
library(MASS)
library(glm.predict)
# Mac Directory
setwd("C:/Users/twili/Desktop/GIThub/StapletonLab/StressSplicing/qPCR")
# In the case of having one CSV containing calculated derivatives, use this code:
#deriv=read.csv(file = "(YEAR_MONTH_PLATE_qPCR_output.csv", header=FALSE)
deriv=read.csv(file = "2018_06_01_plate_qPCR_output_2019_04_04.csv", header=FALSE)
